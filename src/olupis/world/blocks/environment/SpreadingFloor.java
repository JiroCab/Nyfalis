package olupis.world.blocks.environment;

import arc.*;
import arc.audio.*;
import arc.graphics.g2d.*;
import arc.math.*;
import arc.struct.*;
import arc.util.*;
import mindustry.*;
import mindustry.content.*;
import mindustry.entities.*;
import mindustry.game.*;
import mindustry.gen.*;
import mindustry.world.*;
import mindustry.world.blocks.environment.*;
import olupis.world.*;

public class SpreadingFloor extends RotatingFloor{
    /** The amount of times the chance must be rolled */
    public int spreadTries = 3;
    /** Base chance for the tile to try to spread, updated every second */
    public double spreadChance = 0.013;
    /** Max tile offset, leave at 0 for linear spread */
    public int spreadOffset = 0;
    /** Whether this block spreads to all surrounding tiles at once, linear spreading only! */
    public boolean fullSpread = false;
    /** Whether this floor spreads while growing, spreading is always full-linear here */
    public boolean growSpread = false;
    /** The sound played when this spreads */
    public Sound spreadSound = Sounds.none;
    /** An effect spawned at the target tile when spreading */
    public Effect spreadEffect = Fx.none,
    /** An effect this spawns when it upgrades */
    upgradeEffect = Fx.none;
    /** Spreading blacklist */
    public ObjectSet<Block> blacklist = new ObjectSet<>();
    /** Block this can "upgrade" into, upgrading takes just as long as spreading */
    public Block next = null;
    /** Block this can spread around, don't set custom unless necessary */
    public Block set = this;
    /** Efficiency of drills on ores converted by this, set to -1 in order to manually adjust for each ore, otherwise this value will be set for each */
    public float drillEfficiency = 1f;
    /** Whether this floor is used as an overlay, DO NOT USE unless you know what you're doing, it WILL replace ores */
    public boolean overlay = false;
    /** A list of replacements for floors, stock block first, then replacement */
    public ObjectMap<Block, Block> replacements = new ObjectMap<>();
    /** Contains ores generated by this floor */
    public Seq<SpreadingOre> ores = new Seq<>();
    /** Prefix used by ore generation**/
    public String orePrefix;

    public SpreadingFloor(String name, int variants){
        super(name);
        this.variants = variants;
        this.orePrefix = Core.bundle.get(getContentType() + "." + this.name + ".ore-prefix", this.name);
    }

    @Override
    public void init(){
        super.init();

        useColor = !overlay;

        if(growSpread)
            fullSpread = true;

        if(fullSpread)
            spreadOffset = 0;

        Vars.content.blocks().each(b -> {
            if(b instanceof SpreadingFloor
            || b instanceof SpreadingOre
            || b.isFloor() && b.asFloor().isLiquid)
                blacklist.add(b);
        });

        if(next != null)
            blacklist.add(next);
        if(set != null)
            blacklist.add(set);

        handleBlacklist(blacklist);

        Events.on(EventType.ClientLoadEvent.class, e -> generate(false));
        Events.on(EventType.ServerLoadEvent.class, e -> generate(true));
    }

    void generate(boolean headless){
        Vars.content.blocks().select(b -> b instanceof OreBlock o && !o.wallOre && !(b instanceof SpreadingOre)).each(o -> {
            SpreadingOre ore = new SpreadingOre(getName(o));

            ore.itemDrop = o.itemDrop;
            ore.mapColor.set(o.itemDrop.color).sub(0, 0, 0,  0.45f);
            ore.parent = this;

            if(!headless){
                ore.uiIcon = o.uiIcon;
                ore.fullIcon = o.fullIcon;
                ore.variants = o.variants;
                ore.variantRegions = o.variantRegions.clone();
                ore.overlayVariants = variants;
                ore.overlayRegions = variantRegions.clone();
                ore.localizedName = Strings.format("[#@]@[] @", mapColor.toString(), orePrefix,  o.localizedName);
            }

            replacements.put(o, ore);

            ores.add(ore);
            EnvUpdater.generated.add(ore);
        });

        Events.fire(new EnvUpdater.OreUpdateEvent());
    }

    public void addGenerated(ObjectSet<Block> entries){
        blacklist.addAll(entries);

        if(next instanceof SpreadingFloor f){
            ores.each(o -> {
                var in = f.ores.find(r -> r.itemDrop == o.itemDrop);
                if(in != null)
                    o.next = in;
            });
        }else if(next != null)
            ores.each(o -> o.set = next);
    }

    public void handleBlacklist(ObjectSet<Block> list){
        if(set != this && set instanceof SpreadingFloor t){
            if(t.growSpread || t.next == null)
                t.blacklist.addAll(list);
            else t.handleBlacklist(list);
        }

        if(next instanceof SpreadingFloor f){
            if(f.growSpread || f.next == null)
                f.blacklist.addAll(list);
            else f.handleBlacklist(list);
        }
    }

    @Override
    public void drawBase(Tile tile){
        if(overlay)
            Draw.rect(this.variantRegions[Mathf.randomSeed(tile.pos(), 0, Math.max(0, this.variantRegions.length - 1))], tile.worldx(), tile.worldy());
        else
            super.drawBase(tile);
    }

    String getName(Block in){
        return in.name.replaceAll("ore-|olupis-|nyfalis-", "") + name.replaceAll("olupis|nyfalis|-overlay", "");
    }
}
